<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DMN // Multi-Layer Metatron Decoder</title>
    <style>
        body { margin: 0; background: #010409; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { position: absolute; top: 0; left: 0; }
        #ui {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: #00d2ff; letter-spacing: 5px; font-size: 12px; pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }
        #layer-label { color: #ffaa00; font-weight: bold; display: block; margin-top: 10px; font-size: 16px; }
    </style>
</head>
<body>

<div id="ui">
    PROJECTION STATUS: ACTIVE
    <span id="layer-label">SCANNING GRID...</span>
</div>
<canvas id="dmnCanvas"></canvas>

<script>
    const canvas = document.getElementById('dmnCanvas');
    const ctx = canvas.getContext('2d');
    const label = document.getElementById('layer-label');
    let nodes = [];
    let mouse = { x: 0, y: 0, rawX: 0, rawY: 0 };
    const radius = 240;

    function initNodes() {
        nodes = [{x: 0, y: 0, z: 0, id: 0}]; 
        for (let i = 0; i < 6; i++) {
            let a = (i * Math.PI) / 3;
            nodes.push({ x: Math.cos(a) * radius/2, y: Math.sin(a) * radius/2, z: radius/4, id: i+1 });
            nodes.push({ x: Math.cos(a) * radius, y: Math.sin(a) * radius, z: -radius/4, id: i+7 });
        }
    }

    // GEOMETRIC LAYER DEFINITIONS
    const layers = [
        {
            name: "CORE_TETRAHEDRON",
            edges: [[1,3], [3,5], [5,1], [0,1], [0,3], [0,5]],
            range: [0, 80]
        },
        {
            name: "STAR_MERKABA",
            edges: [[1,3], [3,5], [5,1], [2,4], [4,6], [6,2], [1,7], [3,9], [5,11]],
            range: [80, 180]
        },
        {
            name: "GREAT_HEXAHEDRON",
            edges: [[7,8], [8,9], [9,10], [10,11], [11,12], [12,7], [1,7], [2,8], [3,9], [4,10], [5,11], [6,12]],
            range: [180, 1000]
        }
    ];

    window.addEventListener('mousemove', (e) => {
        mouse.rawX = e.clientX;
        mouse.rawY = e.clientY;
        mouse.x = (e.clientX - window.innerWidth/2) * 0.006;
        mouse.y = (e.clientY - window.innerHeight/2) * 0.006;
    });

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        // Calculate distance from center to determine which layer to reveal
        const dist = Math.sqrt(Math.pow(mouse.rawX - cx, 2) + Math.pow(mouse.rawY - cy, 2));
        const activeLayer = layers.find(l => dist >= l.range[0] && dist < l.range[1]) || layers[2];
        label.innerText = activeLayer.name;

        // 1. Draw Global Crystalline Template (The "Static" Grid)
        ctx.setLineDash([]);
        ctx.strokeStyle = 'rgba(0, 210, 255, 0.06)';
        ctx.lineWidth = 1;
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                ctx.beginPath();
                ctx.moveTo(cx + nodes[i].x, cy + nodes[i].y);
                ctx.lineTo(cx + nodes[j].x, cy + nodes[j].y);
                ctx.stroke();
            }
        }

        // 2. Reveal the Hidden Layer
        activeLayer.edges.forEach(edge => {
            const rotatePoint = (p) => {
                let cosY = Math.cos(mouse.x), sinY = Math.sin(mouse.x);
                let x = p.x * cosY - p.z * sinY;
                let z = p.x * sinY + p.z * cosY;
                let cosX = Math.cos(mouse.y), sinX = Math.sin(mouse.y);
                let y = p.y * cosX - z * sinX;
                z = p.y * sinX + z * cosX;
                return {x, y, z};
            };

            let p1 = rotatePoint(nodes[edge[0]]);
            let p2 = rotatePoint(nodes[edge[1]]);
            let avgZ = (p1.z + p2.z) / 2;

            ctx.beginPath();
            if (avgZ > 0) { 
                ctx.setLineDash([4, 3]);
                ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
                ctx.lineWidth = 1;
            } else { 
                ctx.setLineDash([]);
                ctx.strokeStyle = 'rgba(255, 170, 0, 0.9)';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffaa00';
            }

            ctx.moveTo(cx + nodes[edge[0]].x, cy + nodes[edge[0]].y);
            ctx.lineTo(cx + nodes[edge[1]].x, cy + nodes[edge[1]].y);
            ctx.stroke();
            ctx.shadowBlur = 0;
        });

        // 3. Draw Anchor Nodes
        nodes.forEach(n => {
            ctx.fillStyle = 'rgba(0, 210, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(cx + n.x, cy + n.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        requestAnimationFrame(draw);
    }

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initNodes();
    });

    window.dispatchEvent(new Event('resize'));
    draw();
</script>
</body>
</html>